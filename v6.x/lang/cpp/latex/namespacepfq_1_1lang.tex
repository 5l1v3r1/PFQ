\hypertarget{namespacepfq_1_1lang}{}\section{pfq\+:\+:lang Namespace Reference}
\label{namespacepfq_1_1lang}\index{pfq\+::lang@{pfq\+::lang}}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespacepfq_1_1lang_1_1anonymous__namespace_02default_8hpp_03}{anonymous\+\_\+namespace\{default.\+hpp\}}
\item 
 \hyperlink{namespacepfq_1_1lang_1_1experimental}{experimental}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structpfq_1_1lang_1_1Action}{Action}
\item 
struct \hyperlink{structpfq_1_1lang_1_1argument__type}{argument\+\_\+type}
\item 
struct \hyperlink{structpfq_1_1lang_1_1Composition}{Composition}
\item 
struct \hyperlink{structpfq_1_1lang_1_1Function}{Function}
\item 
struct \hyperlink{structpfq_1_1lang_1_1FunctionDescr}{Function\+Descr}
\item 
struct \hyperlink{structpfq_1_1lang_1_1funptr__t}{funptr\+\_\+t}
\item 
struct \hyperlink{structpfq_1_1lang_1_1ipv4__t}{ipv4\+\_\+t}
\item 
struct \hyperlink{structpfq_1_1lang_1_1is__monadic__function}{is\+\_\+monadic\+\_\+function}
\item 
struct \hyperlink{structpfq_1_1lang_1_1is__predicate}{is\+\_\+predicate}
\item 
struct \hyperlink{structpfq_1_1lang_1_1is__predicate_3_01Predicate_3_01Ts_8_8_8_01_4_01_4}{is\+\_\+predicate$<$ Predicate$<$ Ts... $>$ $>$}
\item 
struct \hyperlink{structpfq_1_1lang_1_1is__property}{is\+\_\+property}
\item 
struct \hyperlink{structpfq_1_1lang_1_1is__property_3_01Property_3_01Ts_8_8_8_01_4_01_4}{is\+\_\+property$<$ Property$<$ Ts... $>$ $>$}
\item 
struct \hyperlink{structpfq_1_1lang_1_1KFunction}{K\+Function}
\item 
struct \hyperlink{structpfq_1_1lang_1_1kleisly}{kleisly}
\item 
struct \hyperlink{structpfq_1_1lang_1_1kleisly_3_01KFunction_3_01M_3_01B_01_4_07A_08_01_4_00_01Composition_3_01F_00_01G_01_4_01_4}{kleisly$<$ K\+Function$<$ M$<$ B $>$(\+A) $>$, Composition$<$ F, G $>$ $>$}
\item 
struct \hyperlink{structpfq_1_1lang_1_1kleisly_3_01KFunction_3_01M_3_01B_01_4_07A_08_01_4_00_01KFunction_3_01M_3_01C_01_4_07B_08_4_01_4}{kleisly$<$ K\+Function$<$ M$<$ B $>$(\+A) $>$, K\+Function$<$ M$<$ C $>$(\+B)$>$ $>$}
\item 
struct \hyperlink{structpfq_1_1lang_1_1Predicate}{Predicate}
\item 
struct \hyperlink{structpfq_1_1lang_1_1Property}{Property}
\item 
struct \hyperlink{structpfq_1_1lang_1_1SkBuff}{Sk\+Buff}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{namespacepfq_1_1lang_a683f79c96532eb04a9750215004f6da3}{Net\+Function} = \hyperlink{structpfq_1_1lang_1_1KFunction}{K\+Function}$<$ \hyperlink{structpfq_1_1lang_1_1Action}{Action}$<$ \hyperlink{structpfq_1_1lang_1_1SkBuff}{Sk\+Buff} $>$(\hyperlink{structpfq_1_1lang_1_1SkBuff}{Sk\+Buff}) $>$
\item 
using \hyperlink{namespacepfq_1_1lang_ac239a78ab8b48b8248a19910fa06e25c}{Net\+Predicate} = \hyperlink{structpfq_1_1lang_1_1KFunction}{K\+Function}$<$ bool(\hyperlink{structpfq_1_1lang_1_1SkBuff}{Sk\+Buff}) $>$
\item 
using \hyperlink{namespacepfq_1_1lang_a57429ebee2d34e07e521ffd16d714d89}{Net\+Property} = \hyperlink{structpfq_1_1lang_1_1KFunction}{K\+Function}$<$ uint64\+\_\+t(\hyperlink{structpfq_1_1lang_1_1SkBuff}{Sk\+Buff}) $>$
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::string \hyperlink{namespacepfq_1_1lang_a6b371b706602987f7e45c7558824fa34}{show} (\hyperlink{structpfq_1_1lang_1_1ipv4__t}{ipv4\+\_\+t} value)
\item 
std\+::string \hyperlink{namespacepfq_1_1lang_a7a4c9ec62feae5479366427beeff5b74}{pretty} (\hyperlink{structpfq_1_1lang_1_1ipv4__t}{ipv4\+\_\+t} value)
\item 
std\+::string \hyperlink{namespacepfq_1_1lang_a1e54c94175cad1980fc43030d265b58a}{show} (const \hyperlink{structpfq_1_1lang_1_1argument__type}{argument\+\_\+type} \&arg)
\item 
std\+::string \hyperlink{namespacepfq_1_1lang_a2dc4c3535607e668e86aa96674c41eb0}{pretty} (const \hyperlink{structpfq_1_1lang_1_1argument__type}{argument\+\_\+type} \&arg)
\item 
std\+::string \hyperlink{namespacepfq_1_1lang_a7e9458d3c3b90f405ee6df6cbfc43c58}{show} (const \hyperlink{structpfq_1_1lang_1_1FunctionDescr}{Function\+Descr} \&descr)
\item 
{\footnotesize template$<$typename T $>$ }\\\hyperlink{structpfq_1_1lang_1_1argument__type}{argument\+\_\+type} \hyperlink{namespacepfq_1_1lang_ac28f404ec59b7aea311721e0f26b5577}{make\+\_\+argument} (T const \&x, std\+::vector$<$ \hyperlink{structpfq_1_1lang_1_1FunctionDescr}{Function\+Descr} $>$ const \&ser)
\item 
{\footnotesize template$<$typename... Ts, typename... Ti$>$ }\\std\+::array$<$ \hyperlink{structpfq_1_1lang_1_1argument__type}{argument\+\_\+type}, 8 $>$ \hyperlink{namespacepfq_1_1lang_aacc9139aafd72e1f19af3a74c1fdc6dc}{make\+\_\+arguments} (std\+::tuple$<$ Ts... $>$ const \&args, std\+::tuple$<$ Ti... $>$ const \&ref)
\item 
void \hyperlink{namespacepfq_1_1lang_adffac06fa2bba45eca6f8eeab33262d2}{fix\+\_\+computation} (std\+::ptrdiff\+\_\+t n, std\+::vector$<$ \hyperlink{structpfq_1_1lang_1_1FunctionDescr}{Function\+Descr} $>$ \&vec)
\item 
{\footnotesize template$<$typename Ts , typename std\+::enable\+\_\+if$<$!is\+\_\+monadic\+\_\+function$<$ Ts $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\std\+::pair$<$ std\+::vector$<$ \hyperlink{structpfq_1_1lang_1_1FunctionDescr}{Function\+Descr} $>$, std\+::ptrdiff\+\_\+t $>$ \hyperlink{namespacepfq_1_1lang_ae121f9fc8e23fbd6873d45d02e9adb81}{serialize} (Ts const \&, std\+::ptrdiff\+\_\+t n)
\item 
{\footnotesize template$<$typename... Ts$>$ }\\std\+::pair$<$ std\+::vector$<$ \hyperlink{structpfq_1_1lang_1_1FunctionDescr}{Function\+Descr} $>$, std\+::ptrdiff\+\_\+t $>$ \hyperlink{namespacepfq_1_1lang_acd7f9c34960d4f3511228a5568628acf}{serialize\+\_\+all} (std\+::string symb, std\+::ptrdiff\+\_\+t n, bool cont, std\+::tuple$<$ Ts... $>$ const \&args\+\_\+)
\item 
{\footnotesize template$<$typename... Ts$>$ }\\\hyperlink{structpfq_1_1lang_1_1Property}{Property}$<$ typename std\+::decay$<$ Ts $>$\+::type... $>$ \hyperlink{namespacepfq_1_1lang_a1249450e72229273b0db707a286aea91}{property} (std\+::string symbol, Ts \&\&...args)
\item 
std\+::string \hyperlink{namespacepfq_1_1lang_ac2521931d090c58e1edaf556692f66d2}{pretty} (\hyperlink{structpfq_1_1lang_1_1Property}{Property}$<$$>$ const \&p)
\item 
{\footnotesize template$<$typename... Ts$>$ }\\std\+::string \hyperlink{namespacepfq_1_1lang_ad72cdee2fca49246a75620232dfe061a}{pretty} (\hyperlink{structpfq_1_1lang_1_1Property}{Property}$<$ Ts... $>$ const \&p)
\item 
std\+::string \hyperlink{namespacepfq_1_1lang_ad0e3d7a27621b981fa381f110ba59db7}{show} (\hyperlink{structpfq_1_1lang_1_1Property}{Property}$<$$>$ const \&p)
\item 
{\footnotesize template$<$typename... Ts$>$ }\\std\+::string \hyperlink{namespacepfq_1_1lang_a94bf1496c888adfd3d99e25895ed6df8}{show} (\hyperlink{structpfq_1_1lang_1_1Property}{Property}$<$ Ts... $>$ const \&p)
\item 
{\footnotesize template$<$typename... Ts$>$ }\\std\+::pair$<$ std\+::vector$<$ \hyperlink{structpfq_1_1lang_1_1FunctionDescr}{Function\+Descr} $>$, std\+::ptrdiff\+\_\+t $>$ \hyperlink{namespacepfq_1_1lang_ac9dfedf649f03709f23fc7ca4afc1679}{serialize} (\hyperlink{structpfq_1_1lang_1_1Property}{Property}$<$ Ts... $>$ const \&p, std\+::ptrdiff\+\_\+t n)
\item 
{\footnotesize template$<$typename... Ts$>$ }\\\hyperlink{structpfq_1_1lang_1_1Predicate}{Predicate}$<$ typename std\+::decay$<$ Ts $>$\+::type... $>$ \hyperlink{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{predicate} (std\+::string symbol, Ts \&\&...args)
\item 
std\+::string \hyperlink{namespacepfq_1_1lang_a5bd21fba49ed1266540c831a9110fec6}{pretty} (\hyperlink{structpfq_1_1lang_1_1Predicate}{Predicate}$<$$>$ const \&p)
\item 
{\footnotesize template$<$typename... Ts$>$ }\\std\+::string \hyperlink{namespacepfq_1_1lang_a365497365bebd1ef44492e8027a6b3c0}{pretty} (\hyperlink{structpfq_1_1lang_1_1Predicate}{Predicate}$<$ Ts... $>$ const \&p)
\item 
std\+::string \hyperlink{namespacepfq_1_1lang_aeb7cd494cccb45ea7a0a400a51811646}{show} (\hyperlink{structpfq_1_1lang_1_1Predicate}{Predicate}$<$$>$ const \&p)
\item 
{\footnotesize template$<$typename... Ts$>$ }\\std\+::string \hyperlink{namespacepfq_1_1lang_a42c749f45910e4c14d412cc3db5791e5}{show} (\hyperlink{structpfq_1_1lang_1_1Predicate}{Predicate}$<$ Ts... $>$ const \&p)
\item 
{\footnotesize template$<$typename... Ts$>$ }\\std\+::pair$<$ std\+::vector$<$ \hyperlink{structpfq_1_1lang_1_1FunctionDescr}{Function\+Descr} $>$, std\+::ptrdiff\+\_\+t $>$ \hyperlink{namespacepfq_1_1lang_ad631d8e32cf8613ad1f3f19f1b02cab6}{serialize} (\hyperlink{structpfq_1_1lang_1_1Predicate}{Predicate}$<$ Ts... $>$ const \&p, std\+::ptrdiff\+\_\+t n)
\item 
{\footnotesize template$<$typename... Ts$>$ }\\\hyperlink{structpfq_1_1lang_1_1Function}{Function}$<$ typename std\+::decay$<$ Ts $>$\+::type... $>$ \hyperlink{namespacepfq_1_1lang_a1a4638059d700ae08d0ca63886ff2bb3}{function} (std\+::string symbol, Ts \&\&...args)
\item 
std\+::string \hyperlink{namespacepfq_1_1lang_a2e0ab6225ca9d5195bbebc1c5c58b5fc}{pretty} (\hyperlink{structpfq_1_1lang_1_1Function}{Function}$<$$>$ const \&f)
\item 
{\footnotesize template$<$typename... Ts$>$ }\\std\+::string \hyperlink{namespacepfq_1_1lang_ae99e641e0f2d5461ed2c09ce92a82156}{pretty} (\hyperlink{structpfq_1_1lang_1_1Function}{Function}$<$ Ts... $>$ const \&f)
\item 
std\+::string \hyperlink{namespacepfq_1_1lang_aa99530de2408b7864fd641d2fd595f89}{show} (\hyperlink{structpfq_1_1lang_1_1Function}{Function}$<$$>$ const \&f)
\item 
{\footnotesize template$<$typename... Ts$>$ }\\std\+::string \hyperlink{namespacepfq_1_1lang_adb5a6dd5a3af8c170720c866a7839daa}{show} (\hyperlink{structpfq_1_1lang_1_1Function}{Function}$<$ Ts... $>$ const \&f)
\item 
{\footnotesize template$<$typename... Ts$>$ }\\std\+::pair$<$ std\+::vector$<$ \hyperlink{structpfq_1_1lang_1_1FunctionDescr}{Function\+Descr} $>$, std\+::ptrdiff\+\_\+t $>$ \hyperlink{namespacepfq_1_1lang_a91564354df60bcd58020fbe47e1a7b2a}{serialize} (\hyperlink{structpfq_1_1lang_1_1Function}{Function}$<$ Ts... $>$ const \&p, std\+::ptrdiff\+\_\+t n)
\item 
std\+::pair$<$ std\+::vector$<$ \hyperlink{structpfq_1_1lang_1_1FunctionDescr}{Function\+Descr} $>$, std\+::ptrdiff\+\_\+t $>$ \hyperlink{namespacepfq_1_1lang_aa88658cb028dffc2e03a0fe2e8304bec}{serialize} (std\+::vector$<$ \hyperlink{structpfq_1_1lang_1_1Function}{Function}$<$$>$$>$ const \&cont, std\+::ptrdiff\+\_\+t n)
\item 
{\footnotesize template$<$typename C1 , typename C2 , typename  = typename kleisly$<$typename C1\+::type, typename C2\+::type$>$\+::type$>$ }\\\hyperlink{structpfq_1_1lang_1_1Composition}{Composition}$<$ C1, C2 $>$ \hyperlink{namespacepfq_1_1lang_aa5c4ec63004bfee1742b763ca4a53b23}{operator$>$$>$} (C1 c1, C2 c2)
\item 
{\footnotesize template$<$typename C1 , typename C2 $>$ }\\std\+::string \hyperlink{namespacepfq_1_1lang_a5340947126ab493f4d30d5fe36193978}{pretty} (\hyperlink{structpfq_1_1lang_1_1Composition}{Composition}$<$ C1, C2 $>$ const \&comp)
\item 
{\footnotesize template$<$typename C1 , typename C2 $>$ }\\std\+::string \hyperlink{namespacepfq_1_1lang_a073037bfa3d5b01e3b25af56cd504df3}{show} (\hyperlink{structpfq_1_1lang_1_1Composition}{Composition}$<$ C1, C2 $>$ const \&comp)
\item 
{\footnotesize template$<$typename C1 , typename C2 $>$ }\\std\+::pair$<$ std\+::vector$<$ \hyperlink{structpfq_1_1lang_1_1FunctionDescr}{Function\+Descr} $>$, std\+::size\+\_\+t $>$ \hyperlink{namespacepfq_1_1lang_a10060155d79b978287b3a4c1460ba494}{serialize} (\hyperlink{structpfq_1_1lang_1_1Composition}{Composition}$<$ C1, C2 $>$ const \&f, std\+::ptrdiff\+\_\+t n)
\item 
{\footnotesize template$<$typename P1 , typename P2 , typename std\+::enable\+\_\+if$<$ is\+\_\+predicate$<$ P1 $>$\+::value \&\&is\+\_\+predicate$<$ P2 $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\auto \hyperlink{namespacepfq_1_1lang_af24d9c3092f064b0732a4b601dde2c64}{operator\&} (P1 const \&p1, P2 const \&p2) -\/$>$ decltype(\hyperlink{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{predicate}(nullptr, p1, p2))
\begin{DoxyCompactList}\small\item\em Combine two predicate expressions with a specific boolean \textquotesingle{}and\textquotesingle{} operation. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename P1 , typename P2 , typename std\+::enable\+\_\+if$<$ is\+\_\+predicate$<$ P1 $>$\+::value \&\&is\+\_\+predicate$<$ P2 $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\auto \hyperlink{namespacepfq_1_1lang_a425bb535884185450da7addcdb47f35b}{operator$\vert$} (P1 const \&p1, P2 const \&p2) -\/$>$ decltype(\hyperlink{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{predicate}(nullptr, p1, p2))
\begin{DoxyCompactList}\small\item\em Combine two predicate expressions with a specific boolean \textquotesingle{}or\textquotesingle{} operation. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename P1 , typename P2 , typename std\+::enable\+\_\+if$<$ is\+\_\+predicate$<$ P1 $>$\+::value \&\&is\+\_\+predicate$<$ P2 $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\auto \hyperlink{namespacepfq_1_1lang_aa6692a978788617acebfee6ded6ebbbc}{operator$^\wedge$} (P1 const \&p1, P2 const \&p2) -\/$>$ decltype(\hyperlink{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{predicate}(nullptr, p1, p2))
\begin{DoxyCompactList}\small\item\em Combine two predicate expressions with a specific boolean \textquotesingle{}xor\textquotesingle{} operation. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename P $>$ }\\auto \hyperlink{namespacepfq_1_1lang_aad91ae49c0ddea5a9219f679e8de212a}{not\+\_\+} (P const \&p) -\/$>$ decltype(\hyperlink{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{predicate}(nullptr, p))
\begin{DoxyCompactList}\small\item\em Return a new predicate that evaluates to true, when the given one evaluates to false, and vice versa. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename P , typename std\+::enable\+\_\+if$<$ is\+\_\+property$<$ P $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\auto \hyperlink{namespacepfq_1_1lang_aa358821bfd1326e552c69635b969835d}{operator$<$} (P const \&prop, uint64\+\_\+t arg) -\/$>$ decltype(\hyperlink{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{predicate}(nullptr, prop, arg))
\begin{DoxyCompactList}\small\item\em Return a predicate that evaluates to {\ttfamily true}, if the property is less than the given value. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename P , typename std\+::enable\+\_\+if$<$ is\+\_\+property$<$ P $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\auto \hyperlink{namespacepfq_1_1lang_a039a937311f139f9a6e84c49c6505c70}{operator$<$=} (P const \&prop, uint64\+\_\+t arg) -\/$>$ decltype(\hyperlink{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{predicate}(nullptr, prop, arg))
\item 
{\footnotesize template$<$typename P , typename std\+::enable\+\_\+if$<$ is\+\_\+property$<$ P $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\auto \hyperlink{namespacepfq_1_1lang_a708ca1f29e8dd2461859c46369e89322}{operator$>$} (P const \&prop, uint64\+\_\+t arg) -\/$>$ decltype(\hyperlink{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{predicate}(nullptr, prop, arg))
\item 
{\footnotesize template$<$typename P , typename std\+::enable\+\_\+if$<$ is\+\_\+property$<$ P $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\auto \hyperlink{namespacepfq_1_1lang_a8278e1cf39622e9eb4859f4720da1d16}{operator$>$=} (P const \&prop, uint64\+\_\+t arg) -\/$>$ decltype(\hyperlink{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{predicate}(nullptr, prop, arg))
\item 
{\footnotesize template$<$typename P , typename std\+::enable\+\_\+if$<$ is\+\_\+property$<$ P $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\auto \hyperlink{namespacepfq_1_1lang_a87c8fa322873efdbddaa437f194b72b0}{operator==} (P const \&prop, uint64\+\_\+t arg) -\/$>$ decltype(\hyperlink{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{predicate}(nullptr, prop, arg))
\item 
{\footnotesize template$<$typename P , typename std\+::enable\+\_\+if$<$ is\+\_\+property$<$ P $>$\+::value $>$\+::type $\ast$  = nullptr$>$ }\\auto \hyperlink{namespacepfq_1_1lang_a4943eabefcfed4198394f42f913a14e8}{operator!=} (P const \&prop, uint64\+\_\+t arg) -\/$>$ decltype(\hyperlink{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{predicate}(nullptr, prop, arg))
\item 
{\footnotesize template$<$typename P $>$ }\\auto \hyperlink{namespacepfq_1_1lang_ac247c3827084d381d8518dabfff43bb2}{any\+\_\+bit} (P const \&prop, uint64\+\_\+t mask) -\/$>$ decltype(\hyperlink{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{predicate}(nullptr, prop, mask))
\begin{DoxyCompactList}\small\item\em Return a predicate that evaluates to {\ttfamily true}, if the property has at least one bit set among those specified by the given mask. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename P $>$ }\\auto \hyperlink{namespacepfq_1_1lang_a62b1989f7b5d84549a99b1df46743bd6}{all\+\_\+bit} (P const \&prop, uint64\+\_\+t mask) -\/$>$ decltype(\hyperlink{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{predicate}(nullptr, prop, mask))
\begin{DoxyCompactList}\small\item\em Return a predicate that evaluates to {\ttfamily true}, if the property has all bits set among those specified in the given mask. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structpfq_1_1lang_1_1funptr__t}{pfq\+::lang\+::funptr\+\_\+t} \hyperlink{namespacepfq_1_1lang_a8d957b8f6df7198413d3ff9bd698e682}{funptr} = \{\}
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{pfq\+::lang@{pfq\+::lang}!Net\+Function@{Net\+Function}}
\index{Net\+Function@{Net\+Function}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{Net\+Function}{NetFunction}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf pfq\+::lang\+::\+Net\+Function} = typedef {\bf K\+Function}$<$ {\bf Action}$<${\bf Sk\+Buff}$>$({\bf Sk\+Buff}) $>$}\hypertarget{namespacepfq_1_1lang_a683f79c96532eb04a9750215004f6da3}{}\label{namespacepfq_1_1lang_a683f79c96532eb04a9750215004f6da3}
\index{pfq\+::lang@{pfq\+::lang}!Net\+Predicate@{Net\+Predicate}}
\index{Net\+Predicate@{Net\+Predicate}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{Net\+Predicate}{NetPredicate}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf pfq\+::lang\+::\+Net\+Predicate} = typedef {\bf K\+Function}$<$ bool({\bf Sk\+Buff}) $>$}\hypertarget{namespacepfq_1_1lang_ac239a78ab8b48b8248a19910fa06e25c}{}\label{namespacepfq_1_1lang_ac239a78ab8b48b8248a19910fa06e25c}
\index{pfq\+::lang@{pfq\+::lang}!Net\+Property@{Net\+Property}}
\index{Net\+Property@{Net\+Property}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{Net\+Property}{NetProperty}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf pfq\+::lang\+::\+Net\+Property} = typedef {\bf K\+Function}$<$ uint64\+\_\+t({\bf Sk\+Buff}) $>$}\hypertarget{namespacepfq_1_1lang_a57429ebee2d34e07e521ffd16d714d89}{}\label{namespacepfq_1_1lang_a57429ebee2d34e07e521ffd16d714d89}


\subsection{Function Documentation}
\index{pfq\+::lang@{pfq\+::lang}!all\+\_\+bit@{all\+\_\+bit}}
\index{all\+\_\+bit@{all\+\_\+bit}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{all\+\_\+bit(\+P const \&prop, uint64\+\_\+t mask) -\/$>$ decltype(predicate(nullptr, prop, mask))}{all_bit(P const &prop, uint64_t mask) -> decltype(predicate(nullptr, prop, mask))}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P $>$ auto pfq\+::lang\+::all\+\_\+bit (
\begin{DoxyParamCaption}
\item[{P const \&}]{prop, }
\item[{uint64\+\_\+t}]{mask}
\end{DoxyParamCaption}
) -\/$>$ decltype({\bf predicate}(nullptr, prop, mask))
    \hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a62b1989f7b5d84549a99b1df46743bd6}{}\label{namespacepfq_1_1lang_a62b1989f7b5d84549a99b1df46743bd6}


Return a predicate that evaluates to {\ttfamily true}, if the property has all bits set among those specified in the given mask. 

\index{pfq\+::lang@{pfq\+::lang}!any\+\_\+bit@{any\+\_\+bit}}
\index{any\+\_\+bit@{any\+\_\+bit}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{any\+\_\+bit(\+P const \&prop, uint64\+\_\+t mask) -\/$>$ decltype(predicate(nullptr, prop, mask))}{any_bit(P const &prop, uint64_t mask) -> decltype(predicate(nullptr, prop, mask))}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P $>$ auto pfq\+::lang\+::any\+\_\+bit (
\begin{DoxyParamCaption}
\item[{P const \&}]{prop, }
\item[{uint64\+\_\+t}]{mask}
\end{DoxyParamCaption}
) -\/$>$ decltype({\bf predicate}(nullptr, prop, mask))
    \hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_ac247c3827084d381d8518dabfff43bb2}{}\label{namespacepfq_1_1lang_ac247c3827084d381d8518dabfff43bb2}


Return a predicate that evaluates to {\ttfamily true}, if the property has at least one bit set among those specified by the given mask. 

\index{pfq\+::lang@{pfq\+::lang}!fix\+\_\+computation@{fix\+\_\+computation}}
\index{fix\+\_\+computation@{fix\+\_\+computation}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{fix\+\_\+computation(std\+::ptrdiff\+\_\+t n, std\+::vector$<$ Function\+Descr $>$ \&vec)}{fix_computation(std::ptrdiff_t n, std::vector< FunctionDescr > &vec)}}]{\setlength{\rightskip}{0pt plus 5cm}void pfq\+::lang\+::fix\+\_\+computation (
\begin{DoxyParamCaption}
\item[{std\+::ptrdiff\+\_\+t}]{n, }
\item[{std\+::vector$<$ {\bf Function\+Descr} $>$ \&}]{vec}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_adffac06fa2bba45eca6f8eeab33262d2}{}\label{namespacepfq_1_1lang_adffac06fa2bba45eca6f8eeab33262d2}
\index{pfq\+::lang@{pfq\+::lang}!function@{function}}
\index{function@{function}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{function(std\+::string symbol, Ts \&\&...\+args)}{function(std::string symbol, Ts &&...args)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts$>$ {\bf Function}$<$typename std\+::decay$<$Ts$>$\+::type...$>$ pfq\+::lang\+::function (
\begin{DoxyParamCaption}
\item[{std\+::string}]{symbol, }
\item[{Ts \&\&...}]{args}
\end{DoxyParamCaption}
)}\hypertarget{namespacepfq_1_1lang_a1a4638059d700ae08d0ca63886ff2bb3}{}\label{namespacepfq_1_1lang_a1a4638059d700ae08d0ca63886ff2bb3}
\index{pfq\+::lang@{pfq\+::lang}!make\+\_\+argument@{make\+\_\+argument}}
\index{make\+\_\+argument@{make\+\_\+argument}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{make\+\_\+argument(\+T const \&x, std\+::vector$<$ Function\+Descr $>$ const \&ser)}{make_argument(T const &x, std::vector< FunctionDescr > const &ser)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ {\bf argument\+\_\+type} pfq\+::lang\+::make\+\_\+argument (
\begin{DoxyParamCaption}
\item[{T const \&}]{x, }
\item[{std\+::vector$<$ {\bf Function\+Descr} $>$ const \&}]{ser}
\end{DoxyParamCaption}
)}\hypertarget{namespacepfq_1_1lang_ac28f404ec59b7aea311721e0f26b5577}{}\label{namespacepfq_1_1lang_ac28f404ec59b7aea311721e0f26b5577}
\index{pfq\+::lang@{pfq\+::lang}!make\+\_\+arguments@{make\+\_\+arguments}}
\index{make\+\_\+arguments@{make\+\_\+arguments}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{make\+\_\+arguments(std\+::tuple$<$ Ts... $>$ const \&args, std\+::tuple$<$ Ti... $>$ const \&ref)}{make_arguments(std::tuple< Ts... > const &args, std::tuple< Ti... > const &ref)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts, typename... Ti$>$ std\+::array$<${\bf argument\+\_\+type}, 8$>$ pfq\+::lang\+::make\+\_\+arguments (
\begin{DoxyParamCaption}
\item[{std\+::tuple$<$ Ts... $>$ const \&}]{args, }
\item[{std\+::tuple$<$ Ti... $>$ const \&}]{ref}
\end{DoxyParamCaption}
)}\hypertarget{namespacepfq_1_1lang_aacc9139aafd72e1f19af3a74c1fdc6dc}{}\label{namespacepfq_1_1lang_aacc9139aafd72e1f19af3a74c1fdc6dc}
\index{pfq\+::lang@{pfq\+::lang}!not\+\_\+@{not\+\_\+}}
\index{not\+\_\+@{not\+\_\+}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{not\+\_\+(\+P const \&p) -\/$>$ decltype(predicate(nullptr, p))}{not_(P const &p) -> decltype(predicate(nullptr, p))}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P $>$ auto pfq\+::lang\+::not\+\_\+ (
\begin{DoxyParamCaption}
\item[{P const \&}]{p}
\end{DoxyParamCaption}
) -\/$>$ decltype({\bf predicate}(nullptr, p))
    \hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_aad91ae49c0ddea5a9219f679e8de212a}{}\label{namespacepfq_1_1lang_aad91ae49c0ddea5a9219f679e8de212a}


Return a new predicate that evaluates to true, when the given one evaluates to false, and vice versa. 

\index{pfq\+::lang@{pfq\+::lang}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{operator"!=(\+P const \&prop, uint64\+\_\+t arg) -\/$>$ decltype(predicate(nullptr, prop, arg))}{operator!=(P const &prop, uint64_t arg) -> decltype(predicate(nullptr, prop, arg))}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P , typename std\+::enable\+\_\+if$<$ is\+\_\+property$<$ P $>$\+::value $>$\+::type $\ast$  = nullptr$>$ auto pfq\+::lang\+::operator!= (
\begin{DoxyParamCaption}
\item[{P const \&}]{prop, }
\item[{uint64\+\_\+t}]{arg}
\end{DoxyParamCaption}
) -\/$>$ decltype({\bf predicate}(nullptr, prop, arg))
    \hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a4943eabefcfed4198394f42f913a14e8}{}\label{namespacepfq_1_1lang_a4943eabefcfed4198394f42f913a14e8}
\index{pfq\+::lang@{pfq\+::lang}!operator\&@{operator\&}}
\index{operator\&@{operator\&}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{operator\&(\+P1 const \&p1, P2 const \&p2) -\/$>$ decltype(predicate(nullptr, p1, p2))}{operator&(P1 const &p1, P2 const &p2) -> decltype(predicate(nullptr, p1, p2))}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P1 , typename P2 , typename std\+::enable\+\_\+if$<$ is\+\_\+predicate$<$ P1 $>$\+::value \&\&is\+\_\+predicate$<$ P2 $>$\+::value $>$\+::type $\ast$  = nullptr$>$ auto pfq\+::lang\+::operator\& (
\begin{DoxyParamCaption}
\item[{P1 const \&}]{p1, }
\item[{P2 const \&}]{p2}
\end{DoxyParamCaption}
) -\/$>$ decltype({\bf predicate}(nullptr, p1, p2))
    \hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_af24d9c3092f064b0732a4b601dde2c64}{}\label{namespacepfq_1_1lang_af24d9c3092f064b0732a4b601dde2c64}


Combine two predicate expressions with a specific boolean \textquotesingle{}and\textquotesingle{} operation. 

\index{pfq\+::lang@{pfq\+::lang}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{operator$<$(\+P const \&prop, uint64\+\_\+t arg) -\/$>$ decltype(predicate(nullptr, prop, arg))}{operator<(P const &prop, uint64_t arg) -> decltype(predicate(nullptr, prop, arg))}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P , typename std\+::enable\+\_\+if$<$ is\+\_\+property$<$ P $>$\+::value $>$\+::type $\ast$  = nullptr$>$ auto pfq\+::lang\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{P const \&}]{prop, }
\item[{uint64\+\_\+t}]{arg}
\end{DoxyParamCaption}
) -\/$>$ decltype({\bf predicate}(nullptr, prop, arg))
    \hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_aa358821bfd1326e552c69635b969835d}{}\label{namespacepfq_1_1lang_aa358821bfd1326e552c69635b969835d}


Return a predicate that evaluates to {\ttfamily true}, if the property is less than the given value. 

Example\+:

when (ip\+\_\+ttl $<$ 64, drop) \index{pfq\+::lang@{pfq\+::lang}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{operator$<$=(\+P const \&prop, uint64\+\_\+t arg) -\/$>$ decltype(predicate(nullptr, prop, arg))}{operator<=(P const &prop, uint64_t arg) -> decltype(predicate(nullptr, prop, arg))}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P , typename std\+::enable\+\_\+if$<$ is\+\_\+property$<$ P $>$\+::value $>$\+::type $\ast$  = nullptr$>$ auto pfq\+::lang\+::operator$<$= (
\begin{DoxyParamCaption}
\item[{P const \&}]{prop, }
\item[{uint64\+\_\+t}]{arg}
\end{DoxyParamCaption}
) -\/$>$ decltype({\bf predicate}(nullptr, prop, arg))
    \hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a039a937311f139f9a6e84c49c6505c70}{}\label{namespacepfq_1_1lang_a039a937311f139f9a6e84c49c6505c70}
\index{pfq\+::lang@{pfq\+::lang}!operator==@{operator==}}
\index{operator==@{operator==}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{operator==(\+P const \&prop, uint64\+\_\+t arg) -\/$>$ decltype(predicate(nullptr, prop, arg))}{operator==(P const &prop, uint64_t arg) -> decltype(predicate(nullptr, prop, arg))}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P , typename std\+::enable\+\_\+if$<$ is\+\_\+property$<$ P $>$\+::value $>$\+::type $\ast$  = nullptr$>$ auto pfq\+::lang\+::operator== (
\begin{DoxyParamCaption}
\item[{P const \&}]{prop, }
\item[{uint64\+\_\+t}]{arg}
\end{DoxyParamCaption}
) -\/$>$ decltype({\bf predicate}(nullptr, prop, arg))
    \hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a87c8fa322873efdbddaa437f194b72b0}{}\label{namespacepfq_1_1lang_a87c8fa322873efdbddaa437f194b72b0}
\index{pfq\+::lang@{pfq\+::lang}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{operator$>$(\+P const \&prop, uint64\+\_\+t arg) -\/$>$ decltype(predicate(nullptr, prop, arg))}{operator>(P const &prop, uint64_t arg) -> decltype(predicate(nullptr, prop, arg))}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P , typename std\+::enable\+\_\+if$<$ is\+\_\+property$<$ P $>$\+::value $>$\+::type $\ast$  = nullptr$>$ auto pfq\+::lang\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{P const \&}]{prop, }
\item[{uint64\+\_\+t}]{arg}
\end{DoxyParamCaption}
) -\/$>$ decltype({\bf predicate}(nullptr, prop, arg))
    \hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a708ca1f29e8dd2461859c46369e89322}{}\label{namespacepfq_1_1lang_a708ca1f29e8dd2461859c46369e89322}
\index{pfq\+::lang@{pfq\+::lang}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{operator$>$=(\+P const \&prop, uint64\+\_\+t arg) -\/$>$ decltype(predicate(nullptr, prop, arg))}{operator>=(P const &prop, uint64_t arg) -> decltype(predicate(nullptr, prop, arg))}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P , typename std\+::enable\+\_\+if$<$ is\+\_\+property$<$ P $>$\+::value $>$\+::type $\ast$  = nullptr$>$ auto pfq\+::lang\+::operator$>$= (
\begin{DoxyParamCaption}
\item[{P const \&}]{prop, }
\item[{uint64\+\_\+t}]{arg}
\end{DoxyParamCaption}
) -\/$>$ decltype({\bf predicate}(nullptr, prop, arg))
    \hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a8278e1cf39622e9eb4859f4720da1d16}{}\label{namespacepfq_1_1lang_a8278e1cf39622e9eb4859f4720da1d16}
\index{pfq\+::lang@{pfq\+::lang}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{operator$>$$>$(\+C1 c1, C2 c2)}{operator>>(C1 c1, C2 c2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename C1 , typename C2 , typename  = typename kleisly$<$typename C1\+::type, typename C2\+::type$>$\+::type$>$ {\bf Composition}$<$C1, C2$>$ pfq\+::lang\+::operator$>$$>$ (
\begin{DoxyParamCaption}
\item[{C1}]{c1, }
\item[{C2}]{c2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_aa5c4ec63004bfee1742b763ca4a53b23}{}\label{namespacepfq_1_1lang_aa5c4ec63004bfee1742b763ca4a53b23}
\index{pfq\+::lang@{pfq\+::lang}!operator$^\wedge$@{operator$^\wedge$}}
\index{operator$^\wedge$@{operator$^\wedge$}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{operator$^\wedge$(\+P1 const \&p1, P2 const \&p2) -\/$>$ decltype(predicate(nullptr, p1, p2))}{operator^(P1 const &p1, P2 const &p2) -> decltype(predicate(nullptr, p1, p2))}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P1 , typename P2 , typename std\+::enable\+\_\+if$<$ is\+\_\+predicate$<$ P1 $>$\+::value \&\&is\+\_\+predicate$<$ P2 $>$\+::value $>$\+::type $\ast$  = nullptr$>$ auto pfq\+::lang\+::operator$^\wedge$ (
\begin{DoxyParamCaption}
\item[{P1 const \&}]{p1, }
\item[{P2 const \&}]{p2}
\end{DoxyParamCaption}
) -\/$>$ decltype({\bf predicate}(nullptr, p1, p2))
    \hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_aa6692a978788617acebfee6ded6ebbbc}{}\label{namespacepfq_1_1lang_aa6692a978788617acebfee6ded6ebbbc}


Combine two predicate expressions with a specific boolean \textquotesingle{}xor\textquotesingle{} operation. 

\index{pfq\+::lang@{pfq\+::lang}!operator\texttt{"|}@{operator\texttt{"|}}}
\index{operator\texttt{"|}@{operator\texttt{"|}}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{operator\texttt{"|}(\+P1 const \&p1, P2 const \&p2) -\/$>$ decltype(predicate(nullptr, p1, p2))}{operator|(P1 const &p1, P2 const &p2) -> decltype(predicate(nullptr, p1, p2))}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename P1 , typename P2 , typename std\+::enable\+\_\+if$<$ is\+\_\+predicate$<$ P1 $>$\+::value \&\&is\+\_\+predicate$<$ P2 $>$\+::value $>$\+::type $\ast$  = nullptr$>$ auto pfq\+::lang\+::operator$\vert$ (
\begin{DoxyParamCaption}
\item[{P1 const \&}]{p1, }
\item[{P2 const \&}]{p2}
\end{DoxyParamCaption}
) -\/$>$ decltype({\bf predicate}(nullptr, p1, p2))
    \hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a425bb535884185450da7addcdb47f35b}{}\label{namespacepfq_1_1lang_a425bb535884185450da7addcdb47f35b}


Combine two predicate expressions with a specific boolean \textquotesingle{}or\textquotesingle{} operation. 

\index{pfq\+::lang@{pfq\+::lang}!predicate@{predicate}}
\index{predicate@{predicate}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{predicate(std\+::string symbol, Ts \&\&...\+args)}{predicate(std::string symbol, Ts &&...args)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts$>$ {\bf Predicate}$<$typename std\+::decay$<$Ts$>$\+::type...$>$ pfq\+::lang\+::predicate (
\begin{DoxyParamCaption}
\item[{std\+::string}]{symbol, }
\item[{Ts \&\&...}]{args}
\end{DoxyParamCaption}
)}\hypertarget{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}{}\label{namespacepfq_1_1lang_aca9adafc436b7f851621b979fa1aaf88}
\index{pfq\+::lang@{pfq\+::lang}!pretty@{pretty}}
\index{pretty@{pretty}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{pretty(ipv4\+\_\+t value)}{pretty(ipv4_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string pfq\+::lang\+::pretty (
\begin{DoxyParamCaption}
\item[{{\bf ipv4\+\_\+t}}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a7a4c9ec62feae5479366427beeff5b74}{}\label{namespacepfq_1_1lang_a7a4c9ec62feae5479366427beeff5b74}
\index{pfq\+::lang@{pfq\+::lang}!pretty@{pretty}}
\index{pretty@{pretty}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{pretty(const argument\+\_\+type \&arg)}{pretty(const argument_type &arg)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string pfq\+::lang\+::pretty (
\begin{DoxyParamCaption}
\item[{const {\bf argument\+\_\+type} \&}]{arg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a2dc4c3535607e668e86aa96674c41eb0}{}\label{namespacepfq_1_1lang_a2dc4c3535607e668e86aa96674c41eb0}
\index{pfq\+::lang@{pfq\+::lang}!pretty@{pretty}}
\index{pretty@{pretty}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{pretty(\+Property$<$$>$ const \&p)}{pretty(Property<> const &p)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string pfq\+::lang\+::pretty (
\begin{DoxyParamCaption}
\item[{{\bf Property}$<$$>$ const \&}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_ac2521931d090c58e1edaf556692f66d2}{}\label{namespacepfq_1_1lang_ac2521931d090c58e1edaf556692f66d2}
\index{pfq\+::lang@{pfq\+::lang}!pretty@{pretty}}
\index{pretty@{pretty}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{pretty(\+Property$<$ Ts... $>$ const \&p)}{pretty(Property< Ts... > const &p)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts$>$ std\+::string pfq\+::lang\+::pretty (
\begin{DoxyParamCaption}
\item[{{\bf Property}$<$ Ts... $>$ const \&}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_ad72cdee2fca49246a75620232dfe061a}{}\label{namespacepfq_1_1lang_ad72cdee2fca49246a75620232dfe061a}
\index{pfq\+::lang@{pfq\+::lang}!pretty@{pretty}}
\index{pretty@{pretty}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{pretty(\+Predicate$<$$>$ const \&p)}{pretty(Predicate<> const &p)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string pfq\+::lang\+::pretty (
\begin{DoxyParamCaption}
\item[{{\bf Predicate}$<$$>$ const \&}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a5bd21fba49ed1266540c831a9110fec6}{}\label{namespacepfq_1_1lang_a5bd21fba49ed1266540c831a9110fec6}
\index{pfq\+::lang@{pfq\+::lang}!pretty@{pretty}}
\index{pretty@{pretty}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{pretty(\+Predicate$<$ Ts... $>$ const \&p)}{pretty(Predicate< Ts... > const &p)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts$>$ std\+::string pfq\+::lang\+::pretty (
\begin{DoxyParamCaption}
\item[{{\bf Predicate}$<$ Ts... $>$ const \&}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a365497365bebd1ef44492e8027a6b3c0}{}\label{namespacepfq_1_1lang_a365497365bebd1ef44492e8027a6b3c0}
\index{pfq\+::lang@{pfq\+::lang}!pretty@{pretty}}
\index{pretty@{pretty}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{pretty(\+Function$<$$>$ const \&f)}{pretty(Function<> const &f)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string pfq\+::lang\+::pretty (
\begin{DoxyParamCaption}
\item[{{\bf Function}$<$$>$ const \&}]{f}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a2e0ab6225ca9d5195bbebc1c5c58b5fc}{}\label{namespacepfq_1_1lang_a2e0ab6225ca9d5195bbebc1c5c58b5fc}
\index{pfq\+::lang@{pfq\+::lang}!pretty@{pretty}}
\index{pretty@{pretty}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{pretty(\+Function$<$ Ts... $>$ const \&f)}{pretty(Function< Ts... > const &f)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts$>$ std\+::string pfq\+::lang\+::pretty (
\begin{DoxyParamCaption}
\item[{{\bf Function}$<$ Ts... $>$ const \&}]{f}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_ae99e641e0f2d5461ed2c09ce92a82156}{}\label{namespacepfq_1_1lang_ae99e641e0f2d5461ed2c09ce92a82156}
\index{pfq\+::lang@{pfq\+::lang}!pretty@{pretty}}
\index{pretty@{pretty}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{pretty(\+Composition$<$ C1, C2 $>$ const \&comp)}{pretty(Composition< C1, C2 > const &comp)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename C1 , typename C2 $>$ std\+::string pfq\+::lang\+::pretty (
\begin{DoxyParamCaption}
\item[{{\bf Composition}$<$ C1, C2 $>$ const \&}]{comp}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a5340947126ab493f4d30d5fe36193978}{}\label{namespacepfq_1_1lang_a5340947126ab493f4d30d5fe36193978}
\index{pfq\+::lang@{pfq\+::lang}!property@{property}}
\index{property@{property}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{property(std\+::string symbol, Ts \&\&...\+args)}{property(std::string symbol, Ts &&...args)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts$>$ {\bf Property}$<$typename std\+::decay$<$Ts$>$\+::type...$>$ pfq\+::lang\+::property (
\begin{DoxyParamCaption}
\item[{std\+::string}]{symbol, }
\item[{Ts \&\&...}]{args}
\end{DoxyParamCaption}
)}\hypertarget{namespacepfq_1_1lang_a1249450e72229273b0db707a286aea91}{}\label{namespacepfq_1_1lang_a1249450e72229273b0db707a286aea91}
\index{pfq\+::lang@{pfq\+::lang}!serialize@{serialize}}
\index{serialize@{serialize}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{serialize(\+Ts const \&, std\+::ptrdiff\+\_\+t n)}{serialize(Ts const &, std::ptrdiff_t n)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Ts , typename std\+::enable\+\_\+if$<$!is\+\_\+monadic\+\_\+function$<$ Ts $>$\+::value $>$\+::type $\ast$  = nullptr$>$ std\+::pair$<$std\+::vector$<${\bf Function\+Descr}$>$, std\+::ptrdiff\+\_\+t$>$ pfq\+::lang\+::serialize (
\begin{DoxyParamCaption}
\item[{Ts const \&}]{, }
\item[{std\+::ptrdiff\+\_\+t}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_ae121f9fc8e23fbd6873d45d02e9adb81}{}\label{namespacepfq_1_1lang_ae121f9fc8e23fbd6873d45d02e9adb81}
\index{pfq\+::lang@{pfq\+::lang}!serialize@{serialize}}
\index{serialize@{serialize}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{serialize(\+Property$<$ Ts... $>$ const \&p, std\+::ptrdiff\+\_\+t n)}{serialize(Property< Ts... > const &p, std::ptrdiff_t n)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts$>$ std\+::pair$<$std\+::vector$<${\bf Function\+Descr}$>$, std\+::ptrdiff\+\_\+t$>$ pfq\+::lang\+::serialize (
\begin{DoxyParamCaption}
\item[{{\bf Property}$<$ Ts... $>$ const \&}]{p, }
\item[{std\+::ptrdiff\+\_\+t}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_ac9dfedf649f03709f23fc7ca4afc1679}{}\label{namespacepfq_1_1lang_ac9dfedf649f03709f23fc7ca4afc1679}
\index{pfq\+::lang@{pfq\+::lang}!serialize@{serialize}}
\index{serialize@{serialize}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{serialize(\+Predicate$<$ Ts... $>$ const \&p, std\+::ptrdiff\+\_\+t n)}{serialize(Predicate< Ts... > const &p, std::ptrdiff_t n)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts$>$ std\+::pair$<$std\+::vector$<${\bf Function\+Descr}$>$, std\+::ptrdiff\+\_\+t$>$ pfq\+::lang\+::serialize (
\begin{DoxyParamCaption}
\item[{{\bf Predicate}$<$ Ts... $>$ const \&}]{p, }
\item[{std\+::ptrdiff\+\_\+t}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_ad631d8e32cf8613ad1f3f19f1b02cab6}{}\label{namespacepfq_1_1lang_ad631d8e32cf8613ad1f3f19f1b02cab6}
\index{pfq\+::lang@{pfq\+::lang}!serialize@{serialize}}
\index{serialize@{serialize}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{serialize(\+Function$<$ Ts... $>$ const \&p, std\+::ptrdiff\+\_\+t n)}{serialize(Function< Ts... > const &p, std::ptrdiff_t n)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts$>$ std\+::pair$<$std\+::vector$<${\bf Function\+Descr}$>$, std\+::ptrdiff\+\_\+t$>$ pfq\+::lang\+::serialize (
\begin{DoxyParamCaption}
\item[{{\bf Function}$<$ Ts... $>$ const \&}]{p, }
\item[{std\+::ptrdiff\+\_\+t}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a91564354df60bcd58020fbe47e1a7b2a}{}\label{namespacepfq_1_1lang_a91564354df60bcd58020fbe47e1a7b2a}
\index{pfq\+::lang@{pfq\+::lang}!serialize@{serialize}}
\index{serialize@{serialize}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{serialize(std\+::vector$<$ Function$<$$>$$>$ const \&cont, std\+::ptrdiff\+\_\+t n)}{serialize(std::vector< Function<>> const &cont, std::ptrdiff_t n)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::pair$<$std\+::vector$<${\bf Function\+Descr}$>$, std\+::ptrdiff\+\_\+t$>$ pfq\+::lang\+::serialize (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ {\bf Function}$<$$>$$>$ const \&}]{cont, }
\item[{std\+::ptrdiff\+\_\+t}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_aa88658cb028dffc2e03a0fe2e8304bec}{}\label{namespacepfq_1_1lang_aa88658cb028dffc2e03a0fe2e8304bec}
\index{pfq\+::lang@{pfq\+::lang}!serialize@{serialize}}
\index{serialize@{serialize}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{serialize(\+Composition$<$ C1, C2 $>$ const \&f, std\+::ptrdiff\+\_\+t n)}{serialize(Composition< C1, C2 > const &f, std::ptrdiff_t n)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename C1 , typename C2 $>$ std\+::pair$<$std\+::vector$<${\bf Function\+Descr}$>$, std\+::size\+\_\+t$>$ pfq\+::lang\+::serialize (
\begin{DoxyParamCaption}
\item[{{\bf Composition}$<$ C1, C2 $>$ const \&}]{f, }
\item[{std\+::ptrdiff\+\_\+t}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a10060155d79b978287b3a4c1460ba494}{}\label{namespacepfq_1_1lang_a10060155d79b978287b3a4c1460ba494}
\index{pfq\+::lang@{pfq\+::lang}!serialize\+\_\+all@{serialize\+\_\+all}}
\index{serialize\+\_\+all@{serialize\+\_\+all}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{serialize\+\_\+all(std\+::string symb, std\+::ptrdiff\+\_\+t n, bool cont, std\+::tuple$<$ Ts... $>$ const \&args\+\_\+)}{serialize_all(std::string symb, std::ptrdiff_t n, bool cont, std::tuple< Ts... > const &args_)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts$>$ std\+::pair$<$std\+::vector$<${\bf Function\+Descr}$>$, std\+::ptrdiff\+\_\+t$>$ pfq\+::lang\+::serialize\+\_\+all (
\begin{DoxyParamCaption}
\item[{std\+::string}]{symb, }
\item[{std\+::ptrdiff\+\_\+t}]{n, }
\item[{bool}]{cont, }
\item[{std\+::tuple$<$ Ts... $>$ const \&}]{args\+\_\+}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_acd7f9c34960d4f3511228a5568628acf}{}\label{namespacepfq_1_1lang_acd7f9c34960d4f3511228a5568628acf}
\index{pfq\+::lang@{pfq\+::lang}!show@{show}}
\index{show@{show}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{show(ipv4\+\_\+t value)}{show(ipv4_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string pfq\+::lang\+::show (
\begin{DoxyParamCaption}
\item[{{\bf ipv4\+\_\+t}}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a6b371b706602987f7e45c7558824fa34}{}\label{namespacepfq_1_1lang_a6b371b706602987f7e45c7558824fa34}
\index{pfq\+::lang@{pfq\+::lang}!show@{show}}
\index{show@{show}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{show(const argument\+\_\+type \&arg)}{show(const argument_type &arg)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string pfq\+::lang\+::show (
\begin{DoxyParamCaption}
\item[{const {\bf argument\+\_\+type} \&}]{arg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a1e54c94175cad1980fc43030d265b58a}{}\label{namespacepfq_1_1lang_a1e54c94175cad1980fc43030d265b58a}
\index{pfq\+::lang@{pfq\+::lang}!show@{show}}
\index{show@{show}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{show(const Function\+Descr \&descr)}{show(const FunctionDescr &descr)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string pfq\+::lang\+::show (
\begin{DoxyParamCaption}
\item[{const {\bf Function\+Descr} \&}]{descr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a7e9458d3c3b90f405ee6df6cbfc43c58}{}\label{namespacepfq_1_1lang_a7e9458d3c3b90f405ee6df6cbfc43c58}
\index{pfq\+::lang@{pfq\+::lang}!show@{show}}
\index{show@{show}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{show(\+Property$<$$>$ const \&p)}{show(Property<> const &p)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string pfq\+::lang\+::show (
\begin{DoxyParamCaption}
\item[{{\bf Property}$<$$>$ const \&}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_ad0e3d7a27621b981fa381f110ba59db7}{}\label{namespacepfq_1_1lang_ad0e3d7a27621b981fa381f110ba59db7}
\index{pfq\+::lang@{pfq\+::lang}!show@{show}}
\index{show@{show}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{show(\+Property$<$ Ts... $>$ const \&p)}{show(Property< Ts... > const &p)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts$>$ std\+::string pfq\+::lang\+::show (
\begin{DoxyParamCaption}
\item[{{\bf Property}$<$ Ts... $>$ const \&}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a94bf1496c888adfd3d99e25895ed6df8}{}\label{namespacepfq_1_1lang_a94bf1496c888adfd3d99e25895ed6df8}
\index{pfq\+::lang@{pfq\+::lang}!show@{show}}
\index{show@{show}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{show(\+Predicate$<$$>$ const \&p)}{show(Predicate<> const &p)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string pfq\+::lang\+::show (
\begin{DoxyParamCaption}
\item[{{\bf Predicate}$<$$>$ const \&}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_aeb7cd494cccb45ea7a0a400a51811646}{}\label{namespacepfq_1_1lang_aeb7cd494cccb45ea7a0a400a51811646}
\index{pfq\+::lang@{pfq\+::lang}!show@{show}}
\index{show@{show}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{show(\+Predicate$<$ Ts... $>$ const \&p)}{show(Predicate< Ts... > const &p)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts$>$ std\+::string pfq\+::lang\+::show (
\begin{DoxyParamCaption}
\item[{{\bf Predicate}$<$ Ts... $>$ const \&}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a42c749f45910e4c14d412cc3db5791e5}{}\label{namespacepfq_1_1lang_a42c749f45910e4c14d412cc3db5791e5}
\index{pfq\+::lang@{pfq\+::lang}!show@{show}}
\index{show@{show}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{show(\+Function$<$$>$ const \&f)}{show(Function<> const &f)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string pfq\+::lang\+::show (
\begin{DoxyParamCaption}
\item[{{\bf Function}$<$$>$ const \&}]{f}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_aa99530de2408b7864fd641d2fd595f89}{}\label{namespacepfq_1_1lang_aa99530de2408b7864fd641d2fd595f89}
\index{pfq\+::lang@{pfq\+::lang}!show@{show}}
\index{show@{show}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{show(\+Function$<$ Ts... $>$ const \&f)}{show(Function< Ts... > const &f)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Ts$>$ std\+::string pfq\+::lang\+::show (
\begin{DoxyParamCaption}
\item[{{\bf Function}$<$ Ts... $>$ const \&}]{f}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_adb5a6dd5a3af8c170720c866a7839daa}{}\label{namespacepfq_1_1lang_adb5a6dd5a3af8c170720c866a7839daa}
\index{pfq\+::lang@{pfq\+::lang}!show@{show}}
\index{show@{show}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{show(\+Composition$<$ C1, C2 $>$ const \&comp)}{show(Composition< C1, C2 > const &comp)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename C1 , typename C2 $>$ std\+::string pfq\+::lang\+::show (
\begin{DoxyParamCaption}
\item[{{\bf Composition}$<$ C1, C2 $>$ const \&}]{comp}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacepfq_1_1lang_a073037bfa3d5b01e3b25af56cd504df3}{}\label{namespacepfq_1_1lang_a073037bfa3d5b01e3b25af56cd504df3}


\subsection{Variable Documentation}
\index{pfq\+::lang@{pfq\+::lang}!funptr@{funptr}}
\index{funptr@{funptr}!pfq\+::lang@{pfq\+::lang}}
\subsubsection[{\texorpdfstring{funptr}{funptr}}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf pfq\+::lang\+::funptr\+\_\+t}  pfq\+::lang\+::funptr = \{\}}\hypertarget{namespacepfq_1_1lang_a8d957b8f6df7198413d3ff9bd698e682}{}\label{namespacepfq_1_1lang_a8d957b8f6df7198413d3ff9bd698e682}
